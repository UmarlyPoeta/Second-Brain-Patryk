# üî¢ Pandas - DataFrame.iloc[] - Selekcja oparta na pozycjach

## üìö Co to jest DataFrame.iloc[]?

`DataFrame.iloc[]` to narzƒôdzie w Pandas do selekcji danych opartej na **pozycjach numerycznych** (jak indeksy w li≈õcie Python). To jak wsp√≥≈Çrzƒôdne na mapie - podajesz konkretne liczby i dostajesz dane z tej pozycji! üìç

## üîß Podstawowa sk≈Çadnia

```python
import pandas as pd

# Podstawowa sk≈Çadnia
df.iloc[row_indexer, column_indexer]
df.iloc[row_indexer]  # tylko wiersze, wszystkie kolumny
```

## üíª Praktyczne przyk≈Çady

### 1Ô∏è‚É£ Podstawowa selekcja po pozycji

```python
import pandas as pd

# Przyk≈Çadowy DataFrame
dane = {
    'Imie': ['Anna', 'Jan', 'Maria', 'Piotr', 'Ewa'],
    'Wiek': [25, 30, 35, 28, 32],
    'Miasto': ['Warszawa', 'Krak√≥w', 'Gda≈Ñsk', 'Pozna≈Ñ', 'Wroc≈Çaw'],
    'Pensja': [5000, 6000, 7000, 5500, 6500]
}

df = pd.DataFrame(dane)
print("DataFrame:")
print(df)
print(f"Shape: {df.shape}")

# Pierwszy wiersz (indeks 0)
pierwszy_wiersz = df.iloc[0]
print(f"\nPierwszy wiersz (0):")
print(pierwszy_wiersz)

# Trzeci wiersz, druga kolumna (Maria, Wiek)
warto≈õƒá = df.iloc[2, 1]  # pozycja [2,1]
print(f"\nWarto≈õƒá na pozycji [2,1]: {warto≈õƒá}")

# Ostatni wiersz
ostatni = df.iloc[-1]
print(f"\nOstatni wiersz (-1):")
print(ostatni)
```

### 2Ô∏è‚É£ Selekcja zakres√≥w i list

```python
# Pierwsze 3 wiersze
pierwsze_trzy = df.iloc[0:3]
print("Pierwsze 3 wiersze (0:3):")
print(pierwsze_trzy)

# Ostatnie 2 wiersze
ostatnie_dwa = df.iloc[-2:]
print(f"\nOstatnie 2 wiersze (-2:):")
print(ostatnie_dwa)

# Konkretne wiersze i kolumny przez listy
wybrane = df.iloc[[0, 2, 4], [0, 3]]  # wiersze 0,2,4 i kolumny 0,3
print(f"\nWybrane wiersze i kolumny:")
print(wybrane)

# Co drugi wiersz
co_drugi = df.iloc[::2]
print(f"\nCo drugi wiersz (::2):")
print(co_drugi)

# Pierwszy i ostatni wiersz, ≈õrodkowe kolumny
fragment = df.iloc[[0, -1], 1:3]
print(f"\nFragment [0,-1], 1:3:")
print(fragment)
```

### 3Ô∏è‚É£ Wszystkie wiersze lub kolumny

```python
# Wszystkie wiersze, tylko pierwsza kolumna
pierwsza_kolumna = df.iloc[:, 0]
print("Pierwsza kolumna (wszystkie wiersze):")
print(pierwsza_kolumna)

# Pierwszy wiersz, wszystkie kolumny
pierwszy_wszystkie = df.iloc[0, :]
print(f"\nPierwszy wiersz (wszystkie kolumny):")
print(pierwszy_wszystkie)

# ≈örodkowe kolumny, wszystkie wiersze
srodkowe = df.iloc[:, 1:3]
print(f"\n≈örodkowe kolumny (1:3):")
print(srodkowe)
```

## üéØ Praktyczne przypadki u≈ºycia

### üìä PodglƒÖdanie danych

```python
# Du≈ºy dataset
np.random.seed(42)
duze_dane = pd.DataFrame({
    'A': np.random.randn(1000),
    'B': np.random.randn(1000),
    'C': np.random.randn(1000),
    'D': np.random.randn(1000),
    'E': np.random.randn(1000)
})

print(f"Du≈ºy dataset: {duze_dane.shape}")

# Szybki podglƒÖd - pierwsze 5 wierszy, pierwsze 3 kolumny
podglad = duze_dane.iloc[:5, :3]
print("PodglƒÖd (5x3):")
print(podglad)

# Losowe 10 wierszy dla przeglƒÖdu
import numpy as np
losowe_indeksy = np.random.choice(duze_dane.shape[0], 10, replace=False)
losowe_wiersze = duze_dane.iloc[losowe_indeksy]
print(f"\n10 losowych wierszy:")
print(losowe_wiersze.head())

# Ostatnie kolumny dla sprawdzenia
ostatnie_kolumny = duze_dane.iloc[:10, -2:]
print(f"\nOstatnie 2 kolumny (pierwszych 10 wierszy):")
print(ostatnie_kolumny)
```

### üéØ Dzielenie danych (train/test split rƒôczny)

```python
# Ma≈Çy dataset dla przyk≈Çadu
data = pd.DataFrame({
    'feature1': range(100),
    'feature2': range(100, 200),
    'target': range(200, 300)
})

print(f"Ca≈Ço≈õƒá: {data.shape}")

# Podzia≈Ç 80/20 (train/test)
n_samples = len(data)
train_size = int(0.8 * n_samples)

# Training data (80%)
train_data = data.iloc[:train_size]
print(f"Train: {train_data.shape}")

# Test data (20%)
test_data = data.iloc[train_size:]
print(f"Test: {test_data.shape}")

# Lub mo≈ºna u≈ºyƒá random split
shuffled_indices = np.random.permutation(n_samples)
train_indices = shuffled_indices[:train_size]
test_indices = shuffled_indices[train_size:]

train_random = data.iloc[train_indices]
test_random = data.iloc[test_indices]

print(f"Random train: {train_random.shape}")
print(f"Random test: {test_random.shape}")
```

### üìà Analiza szereg√≥w czasowych

```python
# Dane czasowe
daty = pd.date_range('2023-01-01', periods=365, freq='D')
szereg_czasowy = pd.DataFrame({
    'data': daty,
    'sprzedaz': np.random.randint(100, 1000, 365),
    'koszty': np.random.randint(50, 500, 365)
})

print("Szereg czasowy:")
print(szereg_czasowy.head())

# Pierwszy miesiƒÖc (pierwsze ~30 dni)
pierwszy_miesiac = szereg_czasowy.iloc[:30]
print(f"\nPierwszy miesiƒÖc (30 dni):")
print(f"≈örednia sprzeda≈º: {pierwszy_miesiac.iloc[:, 1].mean():.0f}")

# Ostatni kwarta≈Ç (ostatnie ~90 dni)
ostatni_kwartal = szereg_czasowy.iloc[-90:]
print(f"\nOstatni kwarta≈Ç:")
print(f"≈örednia sprzeda≈º: {ostatni_kwartal.iloc[:, 1].mean():.0f}")

# Co 7. dzie≈Ñ (tygodniowy pattern)
tygodniowo = szereg_czasowy.iloc[::7]
print(f"\nDane co 7 dni: {tygodniowo.shape[0]} punkt√≥w")
```

### üîç Filtrowanie i selekcja pozycyjna

```python
# Dataset ze studentami
studenci = pd.DataFrame({
    'student_id': [f'S{i:03d}' for i in range(1, 21)],
    'matematyka': np.random.randint(60, 100, 20),
    'fizyka': np.random.randint(50, 95, 20),
    'chemia': np.random.randint(55, 98, 20)
})

print("Studenci (pierwsze 5):")
print(studenci.head())

# Top 5 student√≥w (za≈Ç√≥≈ºmy ≈ºe sƒÖ posortowani)
studenci_sorted = studenci.sort_values('matematyka', ascending=False)
top_5 = studenci_sorted.iloc[:5]
print(f"\nTop 5 w matematyce:")
print(top_5[['student_id', 'matematyka']])

# Co drugi student z top 10
co_drugi_top = studenci_sorted.iloc[::2][:5]
print(f"\nCo drugi z top student√≥w:")
print(co_drugi_top[['student_id', 'matematyka']])

# ≈örodkowi studenci (pozycje 8-12)
srodkowi = studenci_sorted.iloc[8:13]
print(f"\n≈örodkowi studenci (pozycje 8-12):")
print(srodkowi[['student_id', 'matematyka']])
```

## üîç Zaawansowane u≈ºycie

### 1Ô∏è‚É£ ≈ÅƒÖczenie z innymi metodami

```python
# DataFrame z danymi sprzeda≈ºowymi
sprzedaz = pd.DataFrame({
    'produkt': [f'P{i}' for i in range(1, 11)],
    'q1': np.random.randint(100, 500, 10),
    'q2': np.random.randint(120, 600, 10),
    'q3': np.random.randint(80, 450, 10),
    'q4': np.random.randint(150, 700, 10)
})

print("Sprzeda≈º produkt√≥w:")
print(sprzedaz)

# Sortuj po Q1, we≈∫ top 3
top_q1 = sprzedaz.nlargest(3, 'q1')
print(f"\nTop 3 produkty w Q1:")
print(top_q1.iloc[:, [0, 1]])  # tylko nazwa i Q1

# Najgorszych 3 w Q4, tylko kwarta≈Çy
bottom_q4_quarters = sprzedaz.nsmallest(3, 'q4').iloc[:, 1:]
print(f"\nNajgorsze 3 w Q4 (tylko kwarta≈Çy):")
print(bottom_q4_quarters)
```

### 2Ô∏è‚É£ Dynamiczne indeksowanie

```python
# DataFrame z r√≥≈ºnƒÖ liczbƒÖ kolumn
def analyze_last_columns(df, n_cols=2):
    """Analizuje ostatnie n kolumn"""
    last_cols = df.iloc[:, -n_cols:]
    return {
        'shape': last_cols.shape,
        'mean': last_cols.mean(),
        'sum': last_cols.sum()
    }

# Test z r√≥≈ºnymi DataFrame
df_small = pd.DataFrame(np.random.rand(5, 3), columns=['A', 'B', 'C'])
df_large = pd.DataFrame(np.random.rand(10, 8), columns=[f'Col{i}' for i in range(8)])

print("Analiza ostatnich 2 kolumn:")
print(f"Small DF: {analyze_last_columns(df_small)['shape']}")
print(f"Large DF: {analyze_last_columns(df_large)['shape']}")
```

### 3Ô∏è‚É£ Sliding window (okno przesuwne)

```python
# Dane czasowe dla okna przesuwnego
ts_data = pd.DataFrame({
    'value': np.random.randn(20).cumsum(),
    'date': pd.date_range('2023-01-01', periods=20)
})

print("Dane czasowe:")
print(ts_data.head())

# Okno przesuwne 5-elementowe
window_size = 5
windows = []

for i in range(len(ts_data) - window_size + 1):
    window = ts_data.iloc[i:i+window_size, 0]  # tylko kolumna 'value'
    windows.append({
        'start_idx': i,
        'end_idx': i+window_size-1,
        'mean': window.mean(),
        'std': window.std()
    })

windows_df = pd.DataFrame(windows)
print(f"\nOkna przesuwne (rozmiar {window_size}):")
print(windows_df.head())
```

## ‚ö†Ô∏è Czƒôste b≈Çƒôdy i pu≈Çapki

### 1Ô∏è‚É£ R√≥≈ºnica miƒôdzy iloc[] a loc[]

```python
# DataFrame z niestandardowym indeksem
df_custom = pd.DataFrame({'A': [1, 2, 3]}, index=[10, 20, 30])
print("DataFrame z custom index:")
print(df_custom)

# iloc u≈ºywa pozycji
print(f"iloc[0]: {df_custom.iloc[0]['A']}")  # pierwszy element (pozycja 0)

# loc u≈ºywa etykiet
print(f"loc[10]: {df_custom.loc[10]['A']}")  # etykieta indeksu '10'

# B≈ÅƒÑD - mieszanie
try:
    # df_custom.iloc[10]  # Nie ma pozycji 10!
    pass
except IndexError:
    print("IndexError - brak pozycji 10")
```

### 2Ô∏è‚É£ Przekraczanie granic

```python
small_df = pd.DataFrame({'A': [1, 2, 3]})

try:
    # out_of_bounds = small_df.iloc[5]  # Index out of bounds!
    pass
except IndexError as e:
    print(f"IndexError: {e}")

# Bezpieczne sprawdzenie
if len(small_df) > 5:
    safe_access = small_df.iloc[5]
else:
    print("Za ma≈Ço wierszy dla indeksu 5")
```

### 3Ô∏è‚É£ Slice vs lista

```python
df_test = pd.DataFrame({'A': range(5), 'B': range(5, 10)})

# Slice - zwraca DataFrame
slice_result = df_test.iloc[1:3]
print(f"Slice type: {type(slice_result)}")

# Single index - zwraca Series
single_result = df_test.iloc[1]
print(f"Single type: {type(single_result)}")

# Lista z jednym elementem - zwraca DataFrame
list_result = df_test.iloc[[1]]
print(f"List type: {type(list_result)}")
```

## üéØ Best Practices

### ‚úÖ Dobre praktyki

```python
# 1. Sprawdzaj rozmiary przed indexowaniem
df = pd.DataFrame({'A': range(10)})

if len(df) > 5:
    safe_slice = df.iloc[:5]

# 2. U≈ºywaj negative indexing dla ko≈Ñca
last_rows = df.iloc[-3:]  # ostatnie 3 wiersze

# 3. ≈ÅƒÖcz z shape dla dynamicznego dostƒôpu
n_rows, n_cols = df.shape
middle_row = df.iloc[n_rows//2]

# 4. U≈ºywaj step dla pr√≥bkowania
sample = df.iloc[::2]  # co drugi wiersz
```

### ‚ùå Unikaj

```python
# Nie u≈ºywaj bezpo≈õrednio du≈ºych liczb bez sprawdzenia
# big_index = df.iloc[99999]  # mo≈ºe nie istnieƒá!

# Nie mieszaj loc i iloc
# df.iloc['some_label']  # iloc tylko pozycje!

# Unikaj wielokrotnego iloc w pƒôtli (wolne)
# for i in range(len(df)):
#     row = df.iloc[i]  # wolniejsze ni≈º iterrows()
```

## üîó PowiƒÖzane funkcje i metody

- `df.loc[]` - selekcja oparta na etykietach
- `df.at[]` / `df.iat[]` - szybka selekcja pojedynczych warto≈õci
- `df.head()` / `df.tail()` - pierwsze/ostatnie wiersze
- `df.sample()` - losowe wiersze
- `df.nlargest()` / `df.nsmallest()` - n najwiƒôkszych/najmniejszych

## üìö Por√≥wnanie metod selekcji

```python
df = pd.DataFrame({
    'A': [1, 2, 3, 4],
    'B': [10, 20, 30, 40]
}, index=['a', 'b', 'c', 'd'])

print("Por√≥wnanie metod:")
print(f"iloc[1,0] (pozycja):  {df.iloc[1, 0]}")
print(f"loc['b','A'] (etykiety): {df.loc['b', 'A']}")
print(f"iat[1,0] (szybkie):   {df.iat[1, 0]}")
print(f"at['b','A'] (szybkie): {df.at['b', 'A']}")

# Wydajno≈õƒá
print(f"head(2):")
print(df.head(2))
print(f"iloc[:2] (r√≥wnowa≈ºne):")
print(df.iloc[:2])
```

## üìù Podsumowanie

`DataFrame.iloc[]` to narzƒôdzie pozycyjnej selekcji:

- üî¢ U≈ºywa **pozycji numerycznych** (jak listy Python)
- üìê Format: `df.iloc[row_positions, column_positions]`
- üéØ Obs≈Çuguje slice (`:`), listy (`[]`), negative indexing (`-1`)
- ‚ö° Szybkie dla znanej struktury danych
- üîç Idealne do iteracji, sampling, dzielenia danych
- ‚ö†Ô∏è Sprawdzaj zawsze rozmiary DataFrame przed dostƒôpem!

To jak GPS wsp√≥≈Çrzƒôdne - podajesz dok≈ÇadnƒÖ pozycjƒô i dostajesz dane! üó∫Ô∏èüìç