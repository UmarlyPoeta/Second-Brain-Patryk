# üî¢ NumPy - numpy.sort() - Sortowanie tablic

## üìö Co to jest numpy.sort()?

`numpy.sort()` to funkcja, kt√≥ra sortuje elementy tablicy w okre≈õlonej kolejno≈õci. To jak porzƒÖdkowanie ksiƒÖ≈ºek na p√≥≈Çce - mo≈ºesz ustawiƒá je alfabetycznie, od najmniejszej do najwiƒôkszej, itp! üìö‚¨ÜÔ∏è

## üîß Podstawowa sk≈Çadnia

```python
import numpy as np

# Podstawowa sk≈Çadnia
numpy.sort(array, axis=-1, kind=None, order=None)
# LUB (metoda tablicy)
array.sort()  # sortuje w miejscu (in-place)
```

## üíª Praktyczne przyk≈Çady

### 1Ô∏è‚É£ Sortowanie podstawowe

```python
import numpy as np

# Tablica 1D
liczby = np.array([64, 34, 25, 12, 22, 11, 90])
print(f"Oryginalne: {liczby}")

# Sortowanie (tworzy kopiƒô)
posortowane = np.sort(liczby)
print(f"Posortowane: {posortowane}")
print(f"Oryginalne (bez zmian): {liczby}")

# Sortowanie w miejscu (zmienia oryginalnƒÖ tablicƒô)
liczby.sort()
print(f"Po sort(): {liczby}")
```

### 2Ô∏è‚É£ Sortowanie malejƒÖce

```python
# Dla sortowania malejƒÖcego u≈ºyj [::-1]
liczby = np.array([64, 34, 25, 12, 22, 11, 90])
print(f"Oryginalne: {liczby}")

# Sortowanie rosnƒÖce, potem odwr√≥cenie
malejace = np.sort(liczby)[::-1]
print(f"MalejƒÖco: {malejace}")

# Alternatywnie z -
minus_sort = -np.sort(-liczby)
print(f"Przez minus: {minus_sort}")
```

### 3Ô∏è‚É£ Sortowanie string√≥w

```python
# Sortowanie alfabetyczne
imiona = np.array(['Zofia', 'Anna', 'Marek', 'Piotr', 'Ewa'])
print(f"Oryginalne: {imiona}")

posortowane_imiona = np.sort(imiona)
print(f"Alfabetycznie: {posortowane_imiona}")

# Sortowanie po d≈Çugo≈õci (trzeba u≈ºyƒá argsort + key function)
dlugosci = np.array([len(name) for name in imiona])
indeksy_dlugosci = np.argsort(dlugosci)
po_dlugosci = imiona[indeksy_dlugosci]
print(f"Po d≈Çugo≈õci: {po_dlugosci}")
```

## üéØ Sortowanie tablic 2D (axis parameter)

### 1Ô∏è‚É£ Sortowanie wierszy (axis=1)

```python
# Macierz 3x4
macierz = np.array([[64, 34, 25, 12],
                    [90, 88, 76, 50],
                    [23, 45, 67, 89]])

print("Oryginalna macierz:")
print(macierz)

# Sortuj ka≈ºdy wiersz osobno
wiersze_sort = np.sort(macierz, axis=1)
print(f"\nWiersze posortowane:")
print(wiersze_sort)
```

### 2Ô∏è‚É£ Sortowanie kolumn (axis=0)

```python
# Ta sama macierz
print("Oryginalna macierz:")
print(macierz)

# Sortuj ka≈ºdƒÖ kolumnƒô osobno
kolumny_sort = np.sort(macierz, axis=0)
print(f"\nKolumny posortowane:")
print(kolumny_sort)
```

### 3Ô∏è‚É£ Sortowanie ca≈Çej macierzy (sp≈Çaszczonej)

```python
# Sortowanie wszystkich element√≥w
wszystko_sort = np.sort(macierz, axis=None)
print(f"\nWszystkie elementy posortowane:")
print(wszystko_sort)
```

## üîç Praktyczne przypadki u≈ºycia

### üìä Analiza wynik√≥w egzamin√≥w

```python
# Wyniki egzamin√≥w student√≥w (wiersze=studenci, kolumny=przedmioty)
wyniki = np.array([[85, 92, 78, 88],  # Student 1: Mat, Fiz, Chem, Bio
                   [76, 84, 90, 82],  # Student 2
                   [94, 88, 85, 91],  # Student 3
                   [68, 72, 75, 79],  # Student 4
                   [89, 95, 87, 93]]) # Student 5

przedmioty = ['Matematyka', 'Fizyka', 'Chemia', 'Biologia']

print("Wyniki egzamin√≥w:")
print(wyniki)

# Sortuj oceny ka≈ºdego studenta (najgorsze ‚Üí najlepsze)
wyniki_sort = np.sort(wyniki, axis=1)
print(f"\nWyniki student√≥w posortowane (rosnƒÖco):")
print(wyniki_sort)

# Najlepsze i najgorsze wyniki ka≈ºdego studenta
print(f"\nAnaliza per student:")
for i in range(len(wyniki)):
    student_wyniki = wyniki_sort[i]
    najgorszy = student_wyniki[0]
    najlepszy = student_wyniki[-1]
    srednia = np.mean(student_wyniki)
    print(f"Student {i+1}: najgorszy={najgorszy}, najlepszy={najlepszy}, ≈õrednia={srednia:.1f}")

# Sortuj wyniki w ka≈ºdym przedmiocie
przedmioty_sort = np.sort(wyniki, axis=0)
print(f"\nWyniki w przedmiotach (najgorsze ‚Üí najlepsze):")
for j, przedmiot in enumerate(przedmioty):
    print(f"{przedmiot}: {przedmioty_sort[:, j]}")
```

### üí∞ Analiza zarobk√≥w

```python
# Zarobki w r√≥≈ºnych dzia≈Çach (tysiƒÖce PLN)
zarobki = np.array([
    [4.5, 5.2, 6.1, 4.8, 5.5],  # IT
    [3.2, 3.8, 4.1, 3.5, 3.9],  # Marketing
    [2.8, 3.1, 3.4, 2.9, 3.2],  # HR
    [3.5, 4.0, 4.5, 3.8, 4.2]   # Sprzeda≈º
])

dzialy = ['IT', 'Marketing', 'HR', 'Sprzeda≈º']

print("Zarobki w dzia≈Çach (tys. PLN):")
for i, dzial in enumerate(dzialy):
    print(f"{dzial:10}: {zarobki[i]}")

# Sortuj zarobki w ka≈ºdym dziale
zarobki_sort = np.sort(zarobki, axis=1)
print(f"\nZarobki posortowane w dzia≈Çach:")
for i, dzial in enumerate(dzialy):
    sorted_pay = zarobki_sort[i]
    print(f"{dzial:10}: {sorted_pay}")
    print(f"           Mediana: {np.median(sorted_pay):.1f}k, Rozstƒôp: {sorted_pay[-1]-sorted_pay[0]:.1f}k")
```

### üéØ Ranking i percentyle

```python
# Wyniki test√≥w wydajno≈õci (im wy≈ºej tym lepiej)
wydajnosc = np.array([87, 92, 78, 94, 85, 89, 76, 91, 83, 88])
print(f"Wyniki wydajno≈õci: {wydajnosc}")

# Sortuj dla analizy percentyli
wydajnosc_sort = np.sort(wydajnosc)
print(f"Posortowane: {wydajnosc_sort}")

# Oblicz percentyle
n = len(wydajnosc_sort)
percentyl_25 = wydajnosc_sort[int(0.25 * n)]
percentyl_50 = wydajnosc_sort[int(0.50 * n)]  # mediana
percentyl_75 = wydajnosc_sort[int(0.75 * n)]

print(f"25. percentyl: {percentyl_25}")
print(f"50. percentyl (mediana): {percentyl_50}")
print(f"75. percentyl: {percentyl_75}")

# Klasyfikuj wyniki
def klasyfikuj_wynik(wynik):
    if wynik >= percentyl_75:
        return "Wysoki"
    elif wynik >= percentyl_50:
        return "≈öredni"
    elif wynik >= percentyl_25:
        return "Niski"
    else:
        return "Bardzo niski"

print(f"\nKlasyfikacja wynik√≥w:")
for wynik in wydajnosc:
    klasa = klasyfikuj_wynik(wynik)
    print(f"Wynik {wynik}: {klasa}")
```

## üöÄ Zaawansowane sortowanie

### 1Ô∏è‚É£ R√≥≈ºne algorytmy sortowania

```python
# R√≥≈ºne algorytmy (kind parameter)
dane = np.random.randint(1, 100, 10)
print(f"Dane do sortowania: {dane}")

# Quicksort (domy≈õlny, szybki dla wiƒôkszo≈õci przypadk√≥w)
quicksort = np.sort(dane, kind='quicksort')
print(f"Quicksort: {quicksort}")

# Mergesort (stabilny, O(n log n) zawsze)
mergesort = np.sort(dane, kind='mergesort')
print(f"Mergesort: {mergesort}")

# Heapsort (nie stabilny, ale zawsze O(n log n))
heapsort = np.sort(dane, kind='heapsort')
print(f"Heapsort: {heapsort}")

print("Wszystkie dajƒÖ ten sam wynik (sƒÖ posortowane!)")
```

### 2Ô∏è‚É£ Sortowanie struktur danych

```python
# Structured arrays
dtype = [('imie', 'U10'), ('wiek', int), ('wynagrodzenie', float)]
pracownicy = np.array([
    ('Anna', 28, 5500.0),
    ('Jan', 35, 6200.0),
    ('Maria', 24, 4800.0),
    ('Piotr', 31, 5800.0)
], dtype=dtype)

print("Pracownicy:")
print(pracownicy)

# Sortuj po wieku
po_wieku = np.sort(pracownicy, order='wiek')
print(f"\nPo wieku:")
print(po_wieku)

# Sortuj po wynagrodzeniu
po_wynagrodzeniu = np.sort(pracownicy, order='wynagrodzenie')
print(f"\nPo wynagrodzeniu:")
print(po_wynagrodzeniu)

# Sortowanie wielokryterialne (najpierw wiek, potem wynagrodzenie)
wielokryterialne = np.sort(pracownicy, order=['wiek', 'wynagrodzenie'])
print(f"\nWielokryterialne (wiek, potem wynagrodzenie):")
print(wielokryterialne)
```

## ‚ö†Ô∏è Czƒôste b≈Çƒôdy i pu≈Çapki

### 1Ô∏è‚É£ sort() vs np.sort()

```python
oryginalne = np.array([3, 1, 4, 1, 5])
kopia = oryginalne.copy()

# np.sort() tworzy KOPIƒò
sorted_copy = np.sort(oryginalne)
print(f"Po np.sort() - oryginalne: {oryginalne}")  # bez zmian!
print(f"Kopia posortowana: {sorted_copy}")

# .sort() modyfikuje W MIEJSCU
kopia.sort()
print(f"Po .sort() - tablica: {kopia}")  # zmieniona!
```

### 2Ô∏è‚É£ Sortowanie z NaN

```python
dane_nan = np.array([3.1, np.nan, 1.5, 2.8, np.nan])
print(f"Z NaN: {dane_nan}")

posortowane = np.sort(dane_nan)
print(f"Posortowane: {posortowane}")
# NaN zawsze idƒÖ na koniec!
```

### 3Ô∏è‚É£ Problemy z axis

```python
macierz = np.array([[3, 1], [2, 4]])
print("Macierz 2x2:")
print(macierz)

# axis=0 (kolumny) vs axis=1 (wiersze)
print(f"axis=0 (sortuj kolumny):\n{np.sort(macierz, axis=0)}")
print(f"axis=1 (sortuj wiersze):\n{np.sort(macierz, axis=1)}")
```

## üéØ Best Practices

### ‚úÖ Dobre praktyki

```python
# 1. U≈ºywaj np.sort() je≈õli nie chcesz modyfikowaƒá orygina≈Çu
original = np.array([3, 1, 4])
sorted_copy = np.sort(original)  # original bez zmian

# 2. U≈ºywaj .sort() dla oszczƒôdno≈õci pamiƒôci przy du≈ºych tablicach
big_array = np.random.rand(1000000)
big_array.sort()  # modyfikuje w miejscu, oszczƒôdza pamiƒôƒá

# 3. Okre≈õlaj axis dla jasno≈õci w 2D+
matrix = np.random.rand(3, 4)
rows_sorted = np.sort(matrix, axis=1)  # jasne ≈ºe sortujemy wiersze

# 4. ≈ÅƒÖcz z argsort() dla indeks√≥w
data = np.array([64, 34, 25, 12])
indices = np.argsort(data)  # indeksy sortowania
```

### ‚ùå Unikaj

```python
# Nie sortuj niepotrzebnie - to kosztuje czas
for i in range(1000):
    # slow = np.sort(some_array)  # je≈õli nie u≈ºywasz wyniku!
    pass

# Nie mieszaj sort() i np.sort()
arr = np.array([3, 1, 4])
# arr.sort()  # teraz arr jest zmienione
# result = np.sort(arr)  # ju≈º i tak posortowane!
```

## üîó PowiƒÖzane funkcje

- `np.argsort()` - indeksy element√≥w po sortowaniu
- `np.lexsort()` - sortowanie leksykograficzne (wielokryterialne)
- `np.partition()` - czƒô≈õciowe sortowanie (k najmniejszych)
- `np.argpartition()` - indeksy czƒô≈õciowego sortowania
- `np.searchsorted()` - znalezienie pozycji dla wstawienia

## üìö Przyk≈Çad z argsort()

```python
# argsort() - bardzo przydatne!
studenci = np.array(['Anna', 'Jan', 'Maria'])
oceny = np.array([85, 92, 78])

print(f"Studenci: {studenci}")
print(f"Oceny: {oceny}")

# Indeksy sortowania po ocenach (rosnƒÖco)
indeksy = np.argsort(oceny)
print(f"Indeksy sortowania: {indeksy}")

# Sortuj student√≥w po ocenach
studenci_po_ocenach = studenci[indeksy]
oceny_posortowane = oceny[indeksy]

print(f"Ranking (od najgorszego):")
for student, ocena in zip(studenci_po_ocenach, oceny_posortowane):
    print(f"{student}: {ocena}")
```

## üìù Podsumowanie

`numpy.sort()` to podstawowe narzƒôdzie do sortowania:

- üìä `np.sort()` tworzy kopiƒô, `.sort()` modyfikuje w miejscu
- ‚¨ÜÔ∏è Domy≈õlnie sortuje rosnƒÖco, dla malejƒÖcego u≈ºyj `[::-1]`
- üìê `axis=0` dla kolumn, `axis=1` dla wierszy, `axis=None` dla wszystkich
- üöÄ R√≥≈ºne algorytmy: quicksort, mergesort, heapsort
- üîç ≈ÅƒÖcz z `argsort()` dla sortowania powiƒÖzanych danych
- ‚ö†Ô∏è NaN zawsze idƒÖ na koniec

To jak sprzƒÖtanie pokoju - wszystko ma swoje miejsce w odpowiedniej kolejno≈õci! üßπ‚ú®